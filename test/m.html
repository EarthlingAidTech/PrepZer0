const mongoose = require("mongoose");

const ActivityTrackerSchema = new mongoose.Schema({
    examId: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: "Exam", 
        required: true 
    },
    userId: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: "User", 
        required: true 
    },
    status: {
        type: String,
        enum: ["active", "inactive", "offline"],
        default: "inactive"
    },
    lastPingTimestamp: {
        type: Date,
        default: Date.now
    },
    pingHistory: [{
        timestamp: {
            type: Date,
            default: Date.now
        },
        status: {
            type: String,
            enum: ["active", "inactive", "offline"],
            default: "active"
        }
    }],
    // Optional: Track browser/device info
    clientInfo: {
        browser: String,
        device: String,
        ip: String
    },
    // When the tracking began (exam started)
    startedAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    // This ensures the document will be automatically deleted after some time
    // Useful if you want the activity records to expire after exams are completed
    expires: '7d' // Optional: documents will be removed after 7 days
});

// Compound index to ensure uniqueness and optimize queries
ActivityTrackerSchema.index({ examId: 1, userId: 1 }, { unique: true });

// Optional: Add a pre-save hook to track history
ActivityTrackerSchema.pre('findOneAndUpdate', async function() {
    const docToUpdate = await this.model.findOne(this.getQuery());
    if (docToUpdate) {
        const newStatus = this._update.status || 'active';
        const newTimestamp = this._update.lastPingTimestamp || new Date();
        
        // Only add to history if status or substantial time has changed
        const lastHistoryEntry = docToUpdate.pingHistory && docToUpdate.pingHistory.length > 0 ? 
            docToUpdate.pingHistory[docToUpdate.pingHistory.length - 1] : null;
            
        if (!lastHistoryEntry || 
            lastHistoryEntry.status !== newStatus || 
            (new Date(newTimestamp) - new Date(lastHistoryEntry.timestamp)) > 30000) { // 30 seconds
            
            // Add to history
            this.update({}, { 
                $push: { 
                    pingHistory: { 
                        timestamp: newTimestamp, 
                        status: newStatus 
                    } 
                } 
            });
        }
    }
});

module.exports = mongoose.model("ActivityTracker", ActivityTrackerSchema);


const mongoose = require("mongoose");

const ExamSchema = new mongoose.Schema({
    name: { type: String, required: true },
    departments: [{ type: String, enum: ["mc", "is", "cs", "et", "ec", "ai", "cv"], required: true }],
    semester: { type: Number, min: 1, max: 8, required: true },
    questionType: { type: String, enum: ["mcq", "coding", "mcq&coding"], required: true },
    numTotalQuestions: { type: Number, default: 0 },
    numMCQs: { type: Number, default: 0 },
    numCoding: { type: Number, default: 0 },
    mcqQuestions: [{ type: mongoose.Schema.Types.ObjectId, ref: "MCQ" }], // change ref to MCQQuestion for CSV upload
    codingQuestions: [{ type: mongoose.Schema.Types.ObjectId, ref: "CodingQuestion" }],
    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
    scheduledAt: { type: Date },
    scheduleTill: { type: Date },
    duration: { type: Number },
    integrityCheck: { type: Boolean, default: false },
    createdAt: { type: Date, default: Date.now },
    testStatus: { type: String, enum: ["draft", "ongoing", "completed"], default: "ongoing" }
});

// Validation before saving the exam
ExamSchema.pre("save", function (next) {
    // Set status to "draft" if either scheduledAt or scheduleTill is missing
    if (!this.scheduledAt || !this.scheduleTill) {
        this.testStatus = "draft";
    }

    // Question type validation
    if (this.questionType === "mcq" && this.numMCQs <= 0) {
        return next(new Error("MCQ exams must have at least one MCQ question."));
    }
    if (this.questionType === "coding" && this.numCoding <= 0) {
        return next(new Error("Coding exams must have at least one coding question."));
    }
    if (this.questionType === "mcq&coding") {
        if (this.numTotalQuestions !== this.numMCQs + this.numCoding) {
            return next(new Error("Total questions must equal MCQs + Coding questions."));
        }
    }
    next();
});

module.exports = mongoose.model("Exam", ExamSchema);

const mongoose = require('mongoose');

const integritySchema = new mongoose.Schema({
    examId: { type: mongoose.Schema.Types.ObjectId, ref: 'Exam', required: true },
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    tabChanges: { type: Number, default: 0 },
    mouseOuts: { type: Number, default: 0 },
    fullscreenExits: { type: Number, default: 0 },
    copyAttempts: { type: Number, default: 0 },
    pasteAttempts: { type: Number, default: 0 },
    focusChanges: { type: Number, default: 0 },
    screenConfiguration: { type: String, default: "Unknown" },
    lastEvent: { type: String, default: "N/A" },
    timestamps: { type: Date, default: Date.now }
});

const Integrity = mongoose.model('Integrity', integritySchema);

module.exports = Integrity;




const mongoose = require("mongoose");

const MCQSchema = new mongoose.Schema({
    examId: { type: mongoose.Schema.Types.ObjectId, ref: "Exam", required: true }, // Links to Exam
    classification: { type: String,  trim: true,
        enum: [
            'Data Structures',
            'Algorithms',
            'Databases',
            'Object-Oriented Programming',
            'Networking',
            'Operating Systems',
            'Software Engineering',
            'Mathematics',
            'Artificial Intelligence',
            'Machine Learning'
          ]
      },
    question: { type: String, required: true },
    options: [{ type: String, required: true }], // Array of options
    correctAnswer: { type: String, required: true }, // The correct option
    level: {type: String, required: true, enum: ['easy', 'medium', 'hard'], default: 'easy'},
    marks: { type: Number, default: 0 }, // Marks assigned to the question
    createdAt: { type: Date, default: Date.now },
    createdBy: { type: String }


});

module.exports = mongoose.model("MCQ", MCQSchema);




const User = require('./usermodel');
const Integrity = require('./Integrity');
const Submission = require('./SubmissionSchema');
const MCQ = require('./MCQQuestion');

class ReportModel {
  async getAssessmentReport(submissionId) {
    try {
      // Fetch submission with populated exam and student details
      const submission = await Submission.findById(submissionId)
        .populate('exam')
        .populate('student')
        .exec();

      if (!submission) {
        throw new Error('Submission not found');
      }

      // Fetch integrity data
      const integrityData = await Integrity.findOne({
        examId: submission.exam._id,
        userId: submission.student._id
      }).exec();

      // Fetch all MCQ questions for this exam
      const mcqQuestions = await MCQ.find({ examId: submission.exam._id }).exec();

      // Map questions with answers
      const questionsWithAnswers = mcqQuestions.map(question => {
        const submittedAnswer = submission.mcqAnswers.find(
          answer => answer.questionId.toString() === question._id.toString()
        );
        
        const isCorrect = submittedAnswer && submittedAnswer.selectedOption === question.correctAnswer;
        
        return {
          _id: question._id,
          question: question.question,
          options: question.options,
          correctAnswer: question.correctAnswer,
          submittedAnswer: submittedAnswer ? submittedAnswer.selectedOption : 'Not answered',
          isCorrect: isCorrect,
          marks: isCorrect ? question.marks : 0
        };
      });

      // Calculate total score and maximum possible score
      const totalScore = questionsWithAnswers.reduce((sum, q) => sum + (q.isCorrect ? q.marks : 0), 0);
      const maxScore = mcqQuestions.reduce((sum, q) => sum + q.marks, 0);

      // Calculate integrity index
      const integrityViolations = integrityData ? 
        (integrityData.tabChanges + 
         integrityData.mouseOuts + 
         integrityData.fullscreenExits + 
         integrityData.copyAttempts + 
         integrityData.pasteAttempts + 
         integrityData.focusChanges) : 0;
      
      const integrityStatus = integrityViolations >= 3 ? 'Unacceptable' : 'Acceptable';

      // Format test duration
      const startTime = new Date(submission.exam.startTime);
      const endTime = new Date(submission.submittedAt);
      const durationMs = endTime - startTime;
      
      const hours = Math.floor(durationMs / (1000 * 60 * 60));
      const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((durationMs % (1000 * 60)) / 1000);
      
      const formattedDuration = `${hours} hr ${minutes} min ${seconds} sec`;
      const allocatedTime = submission.exam.duration ? `${submission.exam.duration} min` : 'Not specified';
      const usedTime = `${formattedDuration} of ${allocatedTime} used`;

      // Fetch all submissions for this exam to calculate ranking
      const allSubmissions = await Submission.find({ exam: submission.exam._id })
        .populate('student')
        .exec();
      
      // Calculate scores for all submissions
      const submissionsWithScores = await Promise.all(allSubmissions.map(async (sub) => {
        // For each submission, calculate the total score
        const answers = sub.mcqAnswers || [];
        
        // Calculate total score for this submission
        let score = 0;
        for (const answer of answers) {
          const question = mcqQuestions.find(q => q._id.toString() === answer.questionId.toString());
          if (question && answer.selectedOption === question.correctAnswer) {
            score += question.marks;
          }
        }
        
        return {
          studentId: sub.student._id,
          studentName: `${sub.student.fname} ${sub.student.lname}`,
          score: score,
          submittedAt: sub.submittedAt
        };
      }));
      
      // Sort submissions by score (descending) and then by submission time (ascending)
      submissionsWithScores.sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score; // Higher score first
        }
        return new Date(a.submittedAt) - new Date(b.submittedAt); // Earlier submission first
      });
      
      // Find the rank of the current student
      const studentRank = submissionsWithScores.findIndex(s => 
        s.studentId.toString() === submission.student._id.toString()
      ) + 1; // Add 1 because array index is 0-based
      
      const totalStudents = submissionsWithScores.length;

      return {
        student: submission.student,
        exam: submission.exam,
        score: {
          obtained: totalScore,
          total: maxScore
        },
        timeAnalysis: {
          startTime,
          endTime,
          duration: usedTime
        },
        integrity: {
          data: integrityData || {},
          status: integrityStatus,
          violations: integrityViolations
        },
        questions: questionsWithAnswers,
        ranking: {
          rank: studentRank,
          totalStudents: totalStudents,
          topPerformers: submissionsWithScores.slice(0, 3) // Get top 5 students
        }
      };
    } catch (error) {
      console.error('Error fetching assessment report:', error);
      throw error;
    }
  }
}

module.exports = new ReportModel();

const mongoose = require("mongoose");

const SubmissionSchema = new mongoose.Schema({

    exam: { type: mongoose.Schema.Types.ObjectId, ref: "Exam", required: true },

    student: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },

    mcqAnswers: [{ questionId: mongoose.Schema.Types.ObjectId, selectedOption: String }],

    codingAnswers: [{ questionId: mongoose.Schema.Types.ObjectId, code: String }],

    score: { type: Number, default: 0 },

    submittedAt: { type: Date, default: Date.now }

});

module.exports = mongoose.model("Submission", SubmissionSchema);



const mongoose  = require("mongoose");
const crypto = require('crypto')
var validator = require('validator');
const passportLocalMongoose = require('passport-local-mongoose')
const findOrCreate = require('mongoose-findorcreate');
const { random } = require("lodash");
const UserSchema = new mongoose.Schema({
        email : {
           type : String ,
            minlength : 4 , 
            maxlength : 55 ,
            trim : true , 
            default : "N  /  A",
            unique : true ,
        }, 
        active : {
            type : Boolean,
            default : false
        },
        USN : { //
            type : String , 
            unique : true , 
            require : true ,
        } ,
        fname : {
            type : String , 
            minlength : 3  ,
            maxlength  : 20 
           
        },
        lname : {
            type : String , 
            minlength : 2  ,
            maxlength  : 15 
           
        },
        usertype: {
            type : String ,
            default: "student",
            enum : ["student","admin","teacher"],required : true
        },
        userallowed : {
            type : Boolean, 
            default : false ,
        },

        dataid : {
            type : String 
        }
        ,
        Department :  { 
            type: String,
            enum: ["mc", "is", "cs", "et", "ec", "ai", "cv"] // enum: ["MCA", "ISE", "CSE", "ETE", "CIV", "COM", "AI"]
             },
      
        Year : {
            type : String ,
            
        }
        ,
        admin_access : {
            default : false ,
            type : Boolean,
            },
        Rollno : {
            type : String ,
            
        },  
        Semester: { 
            type: Number,
             min: 1, max: 8 
            }, 

        password : String ,
        phonecode :{
            type : String ,
            maxlength : 4
        } ,
        location :{
            type : String
        },
        phone : {
        type : Number ,
        minlength : 10 ,
        maxlength : 10
        } ,
            imageurl : {
            type : String ,
            default : "https://cdn-icons-png.flaticon.com/128/456/456212.png"
        },
        created : {
            type : Date , 
            default : Date.now()
        },
        randomurl : {
            type : String ,
        },
        passwordresettoken : String ,
        passwordresetdate : Date ,
   
  
    //USN==> location + Year + Dept + Rollno
    //1BY22CS001==> BY + 22 + CS + 001 
   
})

UserSchema.plugin(passportLocalMongoose, { usernameField : 'email' })
UserSchema.plugin(findOrCreate)
UserSchema.methods.createpasswordresettoken = function(){
const resetToken = crypto.randomBytes(32).toString('hex');
this.passwordresettoken = crypto
.createHash('sha256')
.update(resetToken)
.digest('hex')

this.passwordresetdate = Date.now() + 10 *60*1000
console.log(resetToken , this.passwordresettoken)


return resetToken

}
const User =  mongoose.model('User', UserSchema)
module.exports = User